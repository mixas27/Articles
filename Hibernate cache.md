Одной из основных возможностей Hibernate является использование кэша. При правильной настройке это может давать достаточно большой прирост производительности засчёт сокращения количества запросов к базе данных. Кэш содержит в себе локальную копию данных, которая может сохраняться в памяти либо на диске (имеет смысл, когда приложение и база данных распологаются на разных физических машинах).

Hibernate обращается к кэшу в следующих случаях:

* Приложение выполняет поиск сущности по идентификатору
* Приложение выполняет ленивую загрузку коллекции

Кэши разделяются в зависимости от области видимости (scope) на следующие виды:

* **_Transaction scope cache_** (Кэш привязанный к транзакции, действительный только пока транзакция не завершиться. Каждая транзакция имеет свой кэш, следовательно, доступ к данному кэшу не может быть осуществлён в несколько потоков)
* **_Process scope cache_** (Кэш привязанный к определённому процессу конкретной JVM и общий для многих транзакций с возможностью параллельного доступа)
* **_Cluster scope cache_** (Кэш, общий для нескольких процессов на одной машине или нескольких машин в составе кластера).

По сути, **_Transaction scope cache_** представляет собой кэш первого уровня hibernate, кэш же второго уровня может быть реализован либо в области видимости процесса илибо как распределённый кэш.

Общий алгоритм работы кэша hibernate: 

1. Когда сессия пытается загрузить объект в первую очередь он ищется в кэше первого уровня
2. Если в кэше первого уровня присутствует нужный объект, он возвращается как результат выполнения метода
3. Если в кэше первого уровня объект не был найден, он ищется в кэше второго уровня
4. Если объект сохранён в кэше второго уровня, он сохраняется так же в кэш первого уровня и возвращается в качестве результата метода
5. Если в кэше второго уровня объекта так же не находится, то делается запрос к базе данных, и результат записывается сразу в оба кэша.

Ниже подробенее рассмотрим работу кэша первого и второго уровня.

##Кэш первого уровня

Кэш первого уровня в hibernate связан с объектом сессии, он включён по умолчанию и нет возможности отключить его. Когда вы передаёте объект в метод _save()_, _update()_ или _saveOrUpdate()_, а так же когда пытаетесь обратиться к нему с помощью методов _load()_, _get()_, _scroll()_, _list()_, _iterate()_ выполняется добавление элемента в кэш сессии и следующий раз, когда нужно будет произвести повторную выборку данного объекта из БД в текущей сессии обращения к БД уже не произойдёт. Объект будет взят из кэша.

Обнуление кэша происходит после закрытия сессии. Так же, содержимым кэша можно управлять используя методы класса **_Session_**:

* _contains()_ - проверяет сохранён ли объект в кэше
* _flush()_ - синхронизирует содержимое кэша с базой данных
* _evict()_ - удаляет объект из кэша
* _clear()_ - обнуляет кэш	

##Кэш второго уровня

Кэш второго уровня в hibernate может быть настроен как кэш процесса, так и как распеределённый кэш (в рамках JVM или кластера). В отличие от кэша первого уровня, использование кэша второго уровня является опциональным. Он может быть как включён так и отключён.

В кэше второго уровня сущности хранятся в разобранном состоянии (что-то наподобие сериализованного состояния, однако, используемый алгоритм намного быстрее сериализации). Соответственно, доступ к объектам, сохранённым в кэше второго уроня осуществляется не по сслыке, а по значению. Обусловлено это ещё и тем, что доступ к сущности может осуществляться из параллельных транзакций. Так, каждая транзакция будет иметь свою копию данных.

Учитывая вышеперечисленное, были разработаны следующие стратегии паралельного доступа к кэшу второго уровня:
* **_read only_** - используется для данных, которые часто читаются но никогда не изменяются
* **_nonstrict read write_** - используется для данных, которые изменяются очень редко. При параллельном доступе к данным из разных транзакций данная стратегия не даёт никакой гарантии, что в кэше будут сохранены актуальные данные, так как при изменении данные не блокируются для чтения. Не слудует использовать данную стратегию, если небольшая вероятность считывания устаревших данных критична для приложения
* **_read write_** - используется для данных которые гораздо чаще читаются, чем обновляются, однако, устаревание которых критично для приложения. В данной стратегии данные блокируются для чтения при их изменении. Данная стратегия обеспечивает уровень изоляции транзакций *read commited*.
* **_transactional_** - используется, когда необходима изоляция транзакций вполоть до уровня *repeatable read*. Так же как и предыдущие используется для данных, которые гораздо чаще читаются нежели обновляются.

Вообще, кэш второго уровня не рекомендуется использовать для данных, которые должны изменяться слишком часто, так как затраты производительности на поддержание актуальности кэша могут оказаться больше чем выйгрыш от использования кэша.


Ни одна из вышеперечисленных стратегий не реализуется самим хибернэйтом. Для этого используются провайдеры кэша, основные из которых:

* **_EhCache_** - изначально разрабатывался как кэш уровня процесса, однако, в последник версиях появилась возможность реализации так же распределённого кэша. Имеется поддрержка кэша запросов и выгрузки данных на диск.
* **_OpenSymphony OSCache_** - реализует кэш только на уровне процесса. Поддерживает кэш запросов и выгрузку данных на диск.
* **_SwarmCache_** - распределённый кэш, который базирется на *JGroups*. Нет поддержки кэша запросов.
* **_JBoss Cache_** — может быть как локальным так и распределённым. Это полностью транзакционный кэш с возможностью репликации и инвалидаци, а так же с возможностью обмена как синхронными так и асинхронными валидационными сообщениями.

Однако, не каждый провайдер совместим с каждым типом стратегии параллельного доступа (смотри таблицу ниже)


 |Read-only|Nonstrict-read-write|Read-write|Transactional
---|---|---|---|--- 
EhCache|Yes|Yes|Yes|No
OSCache|Yes|Yes|Yes|No
SwarmCache|Yes|Yes|No|No
Jboss Cache|Yes|No|No|Yes
 
Стоит заметить, что для удобства поиска, сущности разных классов, а так же сущности, принадлежащие разным коллекциям, сохраняются в разных регионах кэша. Под регионом, в данном случае, понимается некая именованная область кэша. Имя региона совпадает с именем класса, в случае кэширования классов, или с именем каласса объеденённым с именем свойства, в случае кэширования коллекций. Типичная настройка региона кэша на примере EhCache приведена наже:

```xml
<cache name="org.example.model.Entity"
	maxElementsInMemory="500" 
	timeToIdleSeconds="0" 
	timeToLiveSeconds="0" 
	eternal="true" 
	overflowToDisk="false" 
/>
```

Рассмотрим подробнее каждый из параметров:

1. **_name_** — имя региона кэша
2. **_maxElemetsInMemory_** — максимально возможное число объектов, хранимых в памяти
3. **_timeToIdleSeconds_** — задаёт время жизни объекта в кэше с последнего обращения
4. **_timeToLiveSeconds_** — задаёт время жизни объекта в кэше, начиная с его помещения туда
5. **_eternal_** — атрибут определяющий будут ли элементы удаляться из кэша по истечении таймаута. Если этот атрибут установлен в _true_, то таймаут будет игнорироваться
6. **_overflowToDisk_** — атрибут, определяющий, будут ли объекты выгружаться на диск при достижении **_maxElemetsInMemory_**. Имеет смысл включать, если БД и приложение развёрнуты на разных машинах.

##Механизмы синхронизации данных в распределённом кэше

Приложения, которыми пользуется параллельно большое количество людей могут потребовать гораздо больей вычислительной мощности, чем может предоставить единичный сервер. В таком случае, несколько физических машин объеденяются в кластер. Для увеличения общей производительности кластера полезно использовать распределённый кэш hibernate. В таком случае, каждый процесс хранит в своём кэше локальную копию недавно используемых данных.  Поддержание актуальности этих данных осуществляется засчёт сетевого взаимодействия процессов с использованием протокола **_TCP_** либо **_UDP_**.

Механизмы поддержания актуальности данных:

* **_копирование (replication)_** - если состояние сущности было изменнено, то её новое состояние будет разослано каждому члену кластера, что ведёт к повышенному потреблению трафика. А так же принуждает разные узлы кластера сохранять в свём кэше одинаковые данные, что не всегда полезно, так как, обычно, разные члены кластера работают с разными данными.
* **_анулирование (invalidation)_** - если состояние сущности было изменено, то всем узлам кластера рассылается сообщение, указывающее на то, что сущность с определённым идентификатором была изменена. После получения сообщения другие члены кластера проверяют свой кэш на предмет наличия данной сущности, и, если таковая там находися, она удаляется из кэша. Данный подход не создаёт такой большой нагрузки на сеть как предыдущий, а основным его недостатком является то, что если изменённая сущность снова понадобится, она будет загружена запросом к базе данных, а это может привести к дополнительной нагрузке на БД.  Однако, данные, которые необходимы многим узлам кластера обычно изменяются очень и очень редко.

Механизмы передачи сообщений о состоянии объектов:

* **_синхронный_** - после отправи сообщения об изменении объекта в кэше доступ к кэшу блокируется, пока не будет получено подтверждение от всех узлов кластера. 
* **_асинхронный_** -  отправка сообщения об изменении сущности не блокирует доступ к кэшу и не требует подтверждения от всех машин кластера. Вообще, при таком подходе, отпрака сообщений об изменении может происходить не обязательно сразу после изменения, а может быть реализована некая очередь собщений и расслыка в фоновом потоке.

Выбор той или иной стратегии, в основном, зависит от конкретной реализации, а именно насколько часто разные узлы кластера обращаются к одним и тем же модифицируемым данным и насколько критично считывание устаревших данных. 

Полезные ссылки:

* https://docs.jboss.org/hibernate/orm/3.3/reference/en/html/performance.html
* http://balamaci.wordpress.com/category/java/caching/
* http://docs.jboss.org/jbossclustering/hibernate-caching/3.3/en-US/html/concepts-cache-attributes.html
tets